// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createLegalUser = `-- name: CreateLegalUser :exec
INSERT INTO users (name, email, password, cnpj, user_type) VALUES(?,?,?,?,?)
`

type CreateLegalUserParams struct {
	Name     string
	Email    string
	Password string
	Cnpj     sql.NullString
	UserType UsersUserType
}

func (q *Queries) CreateLegalUser(ctx context.Context, arg CreateLegalUserParams) error {
	_, err := q.db.ExecContext(ctx, createLegalUser,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.Cnpj,
		arg.UserType,
	)
	return err
}

const createNaturalUser = `-- name: CreateNaturalUser :exec
INSERT INTO users (name, email, password, cpf, user_type) VALUES(?,?,?,?,?)
`

type CreateNaturalUserParams struct {
	Name     string
	Email    string
	Password string
	Cpf      sql.NullString
	UserType UsersUserType
}

func (q *Queries) CreateNaturalUser(ctx context.Context, arg CreateNaturalUserParams) error {
	_, err := q.db.ExecContext(ctx, createNaturalUser,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.Cpf,
		arg.UserType,
	)
	return err
}

const findLegalUser = `-- name: FindLegalUser :one
SELECT id, name, email, password, cpf, cnpj, created_at, updated_at, user_type FROM users WHERE cnpj = ?
`

func (q *Queries) FindLegalUser(ctx context.Context, cnpj sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, findLegalUser, cnpj)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Cpf,
		&i.Cnpj,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserType,
	)
	return i, err
}

const findNaturalUser = `-- name: FindNaturalUser :one
SELECT id, name, email, password, cpf, cnpj, created_at, updated_at, user_type FROM users WHERE cpf = ?
`

func (q *Queries) FindNaturalUser(ctx context.Context, cpf sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, findNaturalUser, cpf)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Cpf,
		&i.Cnpj,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserType,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, name, email, password, cpf, cnpj, created_at, updated_at, user_type FROM users WHERE email = ?
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Cpf,
		&i.Cnpj,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserType,
	)
	return i, err
}

const findUserById = `-- name: FindUserById :one
SELECT id, name, email, password, cpf, cnpj, created_at, updated_at, user_type FROM users WHERE id = ?
`

func (q *Queries) FindUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Cpf,
		&i.Cnpj,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserType,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET name = COALESCE(?, name), updated_at = NOW() WHERE id = ?
`

type UpdateUserParams struct {
	Name string
	ID   int32
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.Name, arg.ID)
	return err
}
